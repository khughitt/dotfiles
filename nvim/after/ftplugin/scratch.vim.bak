" fun! sen#highlight_tags(lnum, hex, hl_name, start, end) abort
"     let b:fgfull_match_ids = get(b:, 'fgfull_match_ids', [])
"     call add(b:fgfull_match_ids, matchaddpos(a:hl_name, [[a:lnum, a:start, a:end - a:start + 1]]))
" endf
"
let s:interestingWordsGUIColors = ['#aeee00', '#ff0000', '#0000ff', '#b88823', '#ffa724', '#ff2c4b']

let s:senTags = []
let s:senModes = []

let s:hasBuiltColors = 0

" initialise highlight colors 
" initialise length of s:interestingWord list
" initialise s:recentlyUsed list
function! s:buildColors()
  if (s:hasBuiltColors)
    return
  endif
  
  " let ui = s:uiMode()
  let wordColors = g:interestingWordsGUIColors

  " if (exists('g:interestingWordsRandomiseColors') && g:interestingWordsRandomiseColors)
  "   " fisher-yates shuffle
  "   let i = len(wordColors)-1
  "   while i > 0
  "     let j = s:Random(i)
  "     let temp = wordColors[i]
  "     let wordColors[i] = wordColors[j]
  "     let wordColors[j] = temp
  "     let i -= 1
  "   endwhile
  " endif
  " select ui type
  " highlight group indexed from 1
  let currentIndex = 1

  for wordColor in wordColors
    " execute 'hi! def InterestingWord' . currentIndex . ' ' . ui . 'bg=' . wordColor . ' ' . ui . 'fg=Black'
    execute 'hi! def SenTag' . currentIndex . ' guibg=' . wordColor . ' guifg=Black'
    call add(s:senTags, 0)
    call add(s:senModes, 'n')
    " call add(s:recentlyUsed, currentIndex-1)
    let currentIndex += 1
  endfor

  let s:hasBuiltColors = 1
endfunc

function! s:apply_color_to_word(n, word, mode, mid)
  let case = s:checkIgnoreCase(a:word) ? '\c' : '\C'
  if a:mode == 'v'
    let pat = case . '\V\zs' . escape(a:word, '\') . '\ze'
  else
    let pat = case . '\V\<' . escape(a:word, '\') . '\>'
  endif

  try
    call matchadd("SenTag" . (a:n + 1), pat, 1, a:mid)
  catch /E801/      " match id already taken.
  endtry
endfunction
