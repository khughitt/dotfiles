################################################################################
#
# Functions
#
################################################################################

# alias lookup
function al {
    alias | grep $1
}

# function lookup
function fu {
  lines=`ag --no-number "^function" ~/.shell/functions`

  echo $lines | while read line; do 
    # parse function name
    func=$(echo $line | sed 's/function //' | cut -d ' ' -f1);

    # get function definition
    def=`type -af $func`
  
    if echo $def | grep -q $1; then
      echo $def
    fi
  done
}

# relative working directory
function wd {
    echo ${$(pwd)/$HOME\//}
}

# quick history searches
function h {
    history -df -100000 | grep $1
}

# process management
function pg {
    ps -Af | grep $1 | grep -v grep
}

# docker tty
function dty {
    docker exec -it $1 /bin/bash
}

# pandoc + mermaid
function merp {
  pandoc -t html --mathjax -F mermaid-filter -o ${1/.md/.html} $1 
}

# glslviewer
# note: may want to remove --headless option when working more on animated shaders..
function gls {
    outfile="output/${1/.frag/.png}"
    
    glslviewer $1 \
        -w 1080 \
        -h 1080 \
        -s 1 \
        --headless \
        -o $outfile

    icat $outfile 
}

# copy kitty terminfo to conda envs
function conda_kitty {
    for x in ~/conda/envs/*/share/terminfo/x; do 
        echo $x; 
        cp /usr/share/terminfo/x/xterm-kitty $x;
    done
}

#
# fzf notes
# 

# edit note
function notes {
    wd=`pwd`

    cd ~/notes

    # determine fd command to use
    fd_cmd="fd -e md -e mnd"

    # if "-p" switch is present, exclude personal entries from search results
    if [[ $1 == "-p" ]]; then
        fd_cmd="$fd_cmd $MINDFUL_EXCLUDES"
        shift;
    fi

    target=`eval $fd_cmd | grep --color='none' "$1" | fzf -1 --exact --preview 'mdcat {}' --preview-window up`

    if [ ! -z "$target" ]; then
        echo "Opening ~/notes/$target"
        
        # for convenience, keep track of last-accessed file/dir
        export las=`realpath ~/notes/$target`
        export dlas=`dirname $las`

        # open file in editor
        $EDITOR $target
    fi

    cd $wd
}

function notes_dir {
    cd ~/notes

    # determine fd command to use
    fd_cmd="fd -t d"

    # if "-p" switch is present, exclude personal entries from search results
    if [[ $1 == "-p" ]]; then
        fd_cmd="$fd_cmd $MINDFUL_EXCLUDES"
        shift;
    fi

    target=`eval $fd_cmd | grep --color='none' "$1" | fzf -1 --exact`

    if [ ! -z "$target" ]; then
        cd "$HOME/notes/$target"
    fi
}

# add note
function a {
    pwd=`pwd`

    cd ~/notes

    # get directory to store note in
    target=`fd -t d | grep --color='none' "$1" | fzf -1 --exact`

    # prompt user for filename
    if [ ! -z "$target" ]; then
        vared -p "Filename? (${target}/XX): " -c fname
        echo "Opening ~/notes/$target/$fname"
        export las=`realpath ~/notes/$target/$fname`
        export lasd=`dirname $las`
        echo "Overview\n--------\n\nReferences\n----------\n" > $target/$fname
        vim $target/$fname
    fi

    cd $pwd
}

# preview note
function np {
    wd=`pwd`

    cd ~/notes

    # determine fd command to use
    fd_cmd="fd -e md -e mnd"

    # if "-p" switch is present, exclude personal entries from search results
    if [[ $1 == "-p" ]]; then
        fd_cmd="$fd_cmd $MINDFUL_EXCLUDES"
        shift;
    fi

    target=`eval $fd_cmd | grep --color='none' "$1" | fzf -1 --exact --preview 'mdcat {}' --preview-window up`

    if [ ! -z "$target" ]; then
        echo "Opening ~/notes/$target"
        
        # for convenience, keep track of last-accessed file/dir
        export las=`realpath ~/notes/$target`
        export dlas=`dirname $las`

        # open file in editor
        pandoc $target -o /tmp/preview.pdf && zathura /tmp/preview.pdf
    fi

    cd $wd
}

# journal manager
# 
# scans a folder containing project-specific markdown journal entries used to 
# track daily work on different fronts.
#
function jm {
    wd=`pwd`

    cd ~/d/journal
    target=`fd -t f md -X /bin/ls -t | grep --color='none' "$1" | fzf -1 --exact`

    if [ ! -z "$target" ]; then
        vim $target
    fi

    cd $wd
}

# fzf confs
function C {
    target=`fd . "$HOME/.dotfiles" -t f \
            --no-ignore-vcs \
            --exclude "tpm" --exclude "tmp" --exclude "tmux-*" --exclude "Extracted" \
            --exclude "*.xml" --exclude "*.png" --exclude "*.desktop" \
            --exclude "plugged" --exclude "black"`

    target=`echo $target |\
            grep --color='none' "$1" |\
            fzf -1 --exact`

    if [ ! -z "$target" ]; then
        vim $target
    fi
}

# cheatsheets
function c {
    target=`/bin/ls ~/.config/cheat/cheatsheets/ |\
            grep --color='none' "$1" |\
            fzf -1 --exact`

    if [ ! -z "$target" ]; then
        vim ~/.config/cheat/cheatsheets/$target
    fi
}

# gene notes
function gn {
    target=`/bin/ls ~/notes/knowledge/biology/genes/symbols |\
            grep --color='none' "$1" |\
            fzf -1 --exact`

    if [ ! -z "$target" ]; then
        vim ~/notes/knowledge/biology/genes/symbols/$target
    fi
}

function gna {
    pwd=`pwd`

    cd ~/notes/knowledge/biology/genes/symbols

    # prompt user for filename
    vared -p "Filename?: " -c fname
    echo "Opening $fname"

    export las=`realpath ./$fname`
    export lasd=`dirname $las`

    # extract gene symbol from filename and conver to uppercase
    gene=`echo "${fname%.*}" | tr '[:lower:]' '[:upper:]'`
    echo "# ${gene}\n" > $fname

    echo "Overview\n--------\n\nReferences\n----------\n" >> $fname
    vim $fname

    cd $pwd
}

# vim + ag
function va {
    $EDITOR $(ag -l $1)
}

# vim + fzf
function vI {
    target=`fd -t f \
            --exclude "*.svg" --exclude "*.png"`

    target=`echo $target |\
            grep --color='none' "$1" |\
            fzf -1 --exact`

    if [ ! -z "$target" ]; then
        vim $target
    fi
}

# zcat | wc -l
function zcl {
    zcat $1 | wc -l
}

# translate 
function tt {
    sdcv -c $1
    echo "------------------------\n"
    trans zh-TW:en $1
}

#
# checks for some specified gene identifier in several different reference annotations
# and mapping
#
function check_gene {
    query=$1

    # Strip "LOC" prefix, if present;
    # "LOC" genes are listed in NCBI genes without the "LOC" prefix
    # https://www.ncbi.nlm.nih.gov/books/NBK3840/
    if [ "$1" != "${query#LOC}" ]; then
        echo "Removing LOC prefix..."
        query=${query#LOC} 
    fi

    echo "Checking Ensembl GRCh37 GTF..."
    zgrep $query /data/ref/human/ensembl/GRCh37/100/Homo_sapiens.GRCh37.87.gtf.gz

    echo "Checking Ensembl GRCh38 GTF..."
    zgrep $query /data/ref/human/ensembl/GRCh38/100/Homo_sapiens.GRCh38.100.gtf.gz

    echo "Checking HUGO gene symbol mapping..."
    grep $query /data/ref/human/hugo/genenames_2020-08-08.tsv

    echo "Checking NCBI Genes..." 
    zgrep $query /data/ref/human/ncbi/Homo_sapiens.gene_info.gz
}
 
#
# dataset functions
#

# number of columns
function ncol {
    if [[ $1 == *.tsv* ]]; then
        csvgrep -n -t $1 | wc -l
    elif [[ $1 == *.csv* ]]; then
        csvgrep -n $1 | wc -l
    elif [[ $1 == *.feather ]]; then
        python -c \
          "import sys; import pandas as pd; print(pd.read_feather(sys.argv[1]).shape[1])" $1
    else
        echo "Unsupported format..."
    fi
}

# helper function to quickly load a dataset into ipython
function dat {
    # get current data package dir
    # version=`/bin/ls /data/packages | tail -n1`
    # searchpaths="/data/packages/$version"
    searchpaths="/data/packages"

    # include project data and clearn data folders as well
    searchpaths="$searchpaths /data/proj /data/clean"

    # search clean data and most recent data packages
    fd_cmd="fd . -e .tsv -e .feather -e .parquet -e .csv -e .gz $searchpaths"
    target=`eval $fd_cmd | fzf -1 --exact`

    # get extension, excluding .gz 
    filename=${target/.gz/}
    ext="${filename##*.}"

    # launch ipython and attempt to load the dataset
    if [ ! -z "$target" ]; then
        echo "Loading dataset $target..."

        if [ $ext = "feather" ]; then
            ipython -i -c "import pandas as pd; dat=pd.read_feather('$target');"
        elif [ $ext = "parquet" ]; then
            ipython -i -c "import pandas as pd; dat=pd.read_parquet('$target');"
        elif [ $ext = "csv" ]; then
            ipython -i -c "import pandas as pd; dat=pd.read_csv('$target');"
        elif [ $ext = "tsv" ] || [ $ext = "txt" ]; then
            ipython -i -c "import pandas as pd; dat=pd.read_csv('$target', sep='\t');"
        else
            echo "Unrecognized filetype specified: $ext"
        fi
    fi
}

# similar to dat, but limited to datapackages and including preview pane
function datp {
    # get current data package dir
    # version=`/bin/ls /data/packages | tail -n1`
    # searchpaths="/data/packages/$version"
    searchpaths="/data/packages"

    # search clean data and most recent data packages
    fd_cmd="fd datapackage $searchpaths --exclude archive"
    target=`eval $fd_cmd | fzf -1 --exact --preview 'nodes info {}'`

    # launch ipython and attempt to load the dataset
    if [ ! -z "$target" ]; then
        echo "Loading $target..."

        ipython -i -c "from nodes.nodes import DataFrameNode; pkg=DataFrameNode.from_pkg('$target');"
    fi
}

# Fahrenheit to Celsius
function ftoc {
  echo "scale=2;(5/9)*($1-32)" | bc
}

# jq | less
function jql {
  cat $1 | jq -C | /bin/less -R
}
