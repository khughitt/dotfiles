################################################################################
#
# Functions
#
################################################################################

# alias lookup
function al {
    alias | grep $1
}

# function lookup
function fu {
  lines=`ag --no-number "^function" ~/.shell/functions`

  echo $lines | while read line; do 
    # parse function name
    func=$(echo $line | sed 's/function //' | cut -d ' ' -f1);

    # get function definition
    def=`type -af $func`
  
    if echo $def | grep -q $1; then
      echo $def
    fi
  done
}

# copy full path
function cfp {
  realpath -s $1 | xsel
}

# relative working directory
function wd {
    echo ${$(pwd)/$HOME\//}
}

# quick history searches
function h {
    history -df -100000 | grep $1
}

# mkdir & cd into it
function mdd {
  mkdir -p $1
  cd $1
}

# process management
function pg {
    ps -Af | grep $1 | grep -v grep
}

# docker tty
function dty {
    docker exec -it $1 /bin/bash
}

# pandoc + mermaid
function merp {
  pandoc -t html --mathjax -F mermaid-filter -o ${1/.md/.html} $1 
}

# glslviewer
# note: may want to remove --headless option when working more on animated shaders..
function gls {
    outfile="output/${1/.frag/.png}"
    
    glslviewer $1 \
        -w 1080 \
        -h 1080 \
        -s 1 \
        --headless \
        -o $outfile

    icat $outfile 
}

# copy kitty terminfo to conda envs
function conda_kitty {
    for x in ~/conda/envs/*/share/terminfo/x; do 
        echo $x; 
        cp /usr/share/terminfo/x/xterm-kitty $x;
    done
}

# quick hop to a specific data dir (limit to project data to speed things up..)
function data_dir {
    cd /data/proj

    # determine fd command to use
    fd_cmd="fd -t d"

    target=`eval $fd_cmd | grep --color='none' "$1" | fzf -1 --exact`

    if [ ! -z "$target" ]; then
        cd "/data/proj/$target"
    fi
}

# fzf confs
function C {
    target=`fd . "$DOTFILES" -t f \
            --no-ignore-vcs \
            --exclude "tpm" --exclude "tmp" --exclude "tmux-*" --exclude "Extracted" \
            --exclude "*.xml" --exclude "*.png" --exclude "*.desktop" \
            --exclude "plugged" --exclude "black"`

    target=`echo $target |\
            grep --color='none' "$1" |\
            fzf -1 --exact`

    if [ ! -z "$target" ]; then
        vim $target
    fi
}

# cheatsheets
function c {
    target=`/bin/ls ~/.config/cheat/cheatsheets/ |\
            grep --color='none' "$1" |\
            fzf -1 --exact --preview 'bat ~/.config/cheat/cheatsheets/{}' --preview-window up`

    if [ ! -z "$target" ]; then
        vim ~/.config/cheat/cheatsheets/$target
    fi
}

# vim + ag
function va {
    $EDITOR $(ag -l $1)
}

# vim + fzf
function vI {
    target=`fd -t f \
            --exclude "*.svg" --exclude "*.png"`

    target=`echo $target |\
            grep --color='none' "$1" |\
            fzf -1 --exact`

    if [ ! -z "$target" ]; then
        vim $target
    fi
}

# zcat | wc -l
function zcl {
    zcat $1 | wc -l
}

# translate (中文 -> 英語)
function tt {
    sdcv -c $1
    echo "------------------------\n"
    trans zh-TW:en $1
}

# checks for some specified gene identifier in several different reference annotations
# and mapping
function check_gene {
    query=$1

    # Strip "LOC" prefix, if present;
    # "LOC" genes are listed in NCBI genes without the "LOC" prefix
    # https://www.ncbi.nlm.nih.gov/books/NBK3840/
    if [ "$1" != "${query#LOC}" ]; then
        echo "Removing LOC prefix..."
        query=${query#LOC} 
    fi

    echo "Checking Ensembl GRCh37 GTF..."
    zgrep $query /data/ref/human/ensembl/GRCh37/100/Homo_sapiens.GRCh37.87.gtf.gz

    echo "Checking Ensembl GRCh38 GTF..."
    zgrep $query /data/ref/human/ensembl/GRCh38/100/Homo_sapiens.GRCh38.100.gtf.gz

    echo "Checking HUGO gene symbol mapping..."
    grep $query /data/ref/human/hugo/genenames_2020-08-08.tsv

    echo "Checking NCBI Genes..." 
    zgrep $query /data/ref/human/ncbi/Homo_sapiens.gene_info.gz
}
 
#
# dataset functions
#

# number of columns
function ncol {
    if [[ $1 == *.tsv* ]]; then
        csvgrep -n -t $1 | wc -l
    elif [[ $1 == *.csv* ]]; then
        csvgrep -n $1 | wc -l
    elif [[ $1 == *.feather ]]; then
        python -c \
          "import sys; import pandas as pd; print(pd.read_feather(sys.argv[1]).shape[1])" $1
    else
        echo "Unsupported format..."
    fi
}

# opens a specified dataset in ipython
function o {
    # get extension, excluding .gz 
    filename=${1/.gz/}
    ext="${filename##*.}"

    if [ $ext = "feather" ]; then
        ipython -i -c "import pandas as pd; dat=pd.read_feather('$1'); dat;"
    elif [ $ext = "parquet" ]; then
        ipython -i -c "import pandas as pd; dat=pd.read_parquet('$1'); dat;"
    elif [ $ext = "csv" ]; then
        ipython -i -c "import pandas as pd; dat=pd.read_csv('$1'); dat;"
    elif [ $ext = "tsv" ] || [ $ext = "txt" ]; then
        ipython -i -c "import pandas as pd; dat=pd.read_csv('$1', sep='\t'); dat;"
    else
        echo "Unrecognized filetype specified: $ext"
    fi
}

# helper function to quickly find and load a dataset from a set of known
# locations into ipython
function dat {
    # data directories to search
    searchpaths="/data/packages /data/proj /data/clean"

    # search clean data and most recent data packages
    fd_cmd="fd . -e .tsv -e .feather -e .parquet -e .csv -e .gz $searchpaths"
    target=`eval $fd_cmd | fzf -1 --exact`

    # launch ipython and attempt to load the dataset
    if [ ! -z "$target" ]; then
        echo "Loading dataset $target..."
        o $target
    fi
}

# similar to dat, but limited to datapackages and including preview pane
function datp {
    # get current data package dir
    # version=`/bin/ls /data/packages | tail -n1`
    # searchpaths="/data/packages/$version"
    searchpaths="/data/packages"

    # search clean data and most recent data packages
    fd_cmd="fd datapackage $searchpaths --exclude archive"
    target=`eval $fd_cmd | fzf -1 --exact --preview 'nodes info {}'`

    # launch ipython and attempt to load the dataset
    if [ ! -z "$target" ]; then
        echo "Loading $target..."

        ipython -i -c "from nodes.nodes import DataFrameNode; pkg=DataFrameNode.from_pkg('$target');"
    fi
}

# set background
function wali {
  wal -i ~/d/linux/backgrounds/3440 --backend haishoku

  # get path to new background
  img=`sleep 1 && tail -1 ~/.fehbg | grep --color='never' -o "/[\/a-zA-Z0-9_\.]*"`

  fname=`basename $img`
  fname=${fname/jpg/}

  outfile="~/music/bitwig/colors/$fname"

  $HOME/bin/haishoku $img $outfile
}

# remove background
function walirm {
  img=$(basename `cat ${HOME}/.cache/wal/wal`)
  fd $img -x rm
  wali
}

# create png palette based on wal colors
function walpal {
  source ~/.cache/wal/colors.sh

  convert -size 64x64 xc:"$color1" xc:"$color2" xc:"$color3" xc:"$color4" xc:"$color5" xc:"$color6" +append /tmp/a.png
  convert -size 64x64 xc:"$color1" xc:"$color2" xc:"$color3" xc:"$color4" xc:"$color5" xc:"$color6" +append /tmp/b.png
  convert -append /tmp/a.png /tmp/b.png ~/.cache/wal/palette.png
}

# fahrenheit to celsius
function ftoc {
  echo "scale=2;(5/9)*($1-32)" | bc
}

# jq | less
function jql {
  cat $1 | jq -C | /bin/less -R
}

# virtual env launcher
function venv {
  wd=`pwd`

  cd ~/venv/
  target=`/bin/ls -t | grep --color='none' "$1" | fzf -1 --exact`

  if [ ! -z "$target" ]; then
    source ~/venv/$target/bin/activate
  fi

  cd $wd
}
