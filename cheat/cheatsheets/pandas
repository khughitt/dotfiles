Basics
------

# rows
axis = 0

# columns
axis = 1

Selection
---------

# get index as an integer
ind = df.index[df["col"] == val].tolist()[0]

# get upper triangular matrix indices
ind = np.triu_indices(5)         # incl. diagonal
ind = np.triu_indices(5, k=1)    # excl. diagonal

# extract values of indices as 1d array
dat.values[ind]

# drop column
dat.drop('col', axis=1)

Iteration
---------

# iterate over rows as dicts
dat.to_dict(orient="records")

# iterate over rows
for index, row in df.iterrows():
    ...

Creation
--------

# dict of columns
pd.DataFrame.from_dict(d)

# dict of rows
pd.DataFrame.from_dict(d, orient='index')

# fix column types after creating from dicts, etc.
df = df.astype({"access_count": int, "date_created": "datetime64[ns]"})

# dataframe of random uniform values
df = pd.DataFrame(np.random.rand(3, 4))

Dates
-----

# convert date column to unix timestamps
df.datetime.values.astype(np.int64) // 10 ** 9

To Dict
-------

# two cols to dict of key:value pairs
dict(zip(x.tag, x.color))

Joins
-----

# inner join by similar column(s)
a.merge(b)
a.merge(b, on=['foo'])

# join on index
a.join(b)

# rbind
df = pd.concat([a, b])

# cbind
df = pd.concat([a, b], axis=1)

# cbind (numpy)
df = np.concatenate((a,b), axis=1)

Adding & Removing Rows/Cols
---------------------------

df.insert(0, "foo", [0, 1, 2])
df.insert(0, "foo", [0, 1, 2], allow_duplicates = True)

df['foo'] = 1

Filtering & Masking
-------------------

# membership
x.isin([..])    # is in 
~x.isin([..])   # not in

# get values in list that are present in columns of a dataframe
set(a).intersection(df.columns)

# find indices present in one dataframe but not another
a.index[~a.index.isin(b.index)]

# filter rows by column value membership
df.loc[df['column_name'].isin(some_values)]

# filter columns by name
dat.loc[:, ~dat.columns.isin(cols_to_remove)]

# ~R's where()
np.where(dat['foo'] > 1)

# ~R's match()
B.reset_index().set_index('c').loc[A.c, 'index'].values

# contains
df.foo.str.contains('bar', na=False)  # ignore missing vals in column

# endswith
x[x.foo.str.endswith('bar')]

# find indices of string in column
df.foo.str.find('bar')

# return boolean series indicating regex presence in column
df.foo.str.find('bar|baz')

# multiple conditions (wrap each in parens)
x[(x.foo > 3) & (x.bar < 10)]

Min/Max
-------

# get indices of column with max value for each row
df.idxmax(axis=1)

Sort
----

# sort by column
dat.sort_values('foo')

# sort by column (descending)
dat.sort_values('foo', ascending=False)

Grouping / Summarization
------------------------

# group by -> sum
dat.groupby('tag').agg(sum)

# group by -> count
dat.groupby('tag').agg('count')

# group by -> sort
dat.groupby('seed').apply(pd.DataFrame.sort_values, 'tag')
dat.groupby('seed').sort_values('tag')

# group by -> count -> max -> sample
dat.groupby(["path", "seed"]).count().max(axis=1).groupby("path").sample(1)

# get first item from each group
df.groupby('foo').first()

Counting
--------

# convert a list to a series of frequencies
pd.Series(['a', 'a', 'b', 'c']).value_counts()

Matrix operations
-----------------

# set diagonal to zero
mat.values[tuple([np.arange(mat.shape[0])] * 2)] = 0

# convert count matrix to a co-occurence matrix
a.T.dot(a)

Reshaping
---------

# dataframe -> 1d ndarray
dat.values.ravel()

# dataframe -> 1d ndarray (upper-triangular matrix only, excluding diagonal)
ind = np.triu_indices(5, k=1)
dat.values[ind]

# pivot long -> wide
df.pivot_table(index='patient', columns='obs', values='score', fill_value=0)
#df.pivot(index='patient', columns='obs', values='score')

Printing
--------

df.to_markdown()

Plotting
--------

# density plot for column "score"
import matplotlib.pyplot as plt
ax = dat.score.plot.kde()
plt.show()
