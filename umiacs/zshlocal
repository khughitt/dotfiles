# Set PATH
#source ~/.zshpath


# launch more recent z shell
if [ $(echo $ZSH_VERSION | sed "s/\.//g") -lt 500 ]; then
    exec /cbcb/lab/nelsayed/local/bin/zsh -l
fi

## switch main group to hpgl
if [ $(id -gn) != "hpgl" ]; then
    newgrp hpgl
    exit
fi

#Enable group read access
umask 0002

# fix zsh fpath
#export FPATH="$PREFIX/usr/share/zsh/site-functions:$PREFIX/usr/share/zsh/functions:$FPATH"
#fpath=( $fpath $PREFIX/usr/share/zsh/site-functions )
#fpath=( $fpath $PREFIX/usr/share/zsh/functions )

# ibis doesn't like my java settings
unset _JAVA_OPTIONS

# load CBCB environmental settings, including Gnu modules support
#source /cbcb/software/share/dotfiles/bashrc.cbcb
# Or, just load module support
#minit=/opt/stow/Modules/3.2.9/init/bash
#if [ -f $minit ]; then
#   . $minit
#fi

# ZSH
ZSH_THEME='gallois'
plugins=(git)

# qstat tweak
alias qstat="date && qstat"

# Lab settings
export LOGS="${LAB}/logs"
export PBS_WORKSTATION=${PBS_WORKSTATION-" -V -S /cbcb/lab/nelsayed/local/bin/bash -q workstation -l walltime=12:00:00 "}
export PBS_THROUGHPUT=${PBS_THROUGHPUT-" -V -S /cbcb/lab/nelsayed/local/bin/bash -q new_throughput -l walltime=12:00:00 "}
export PBS_LARGE=${PBS_LARGS-" -V -S /cbcb/lab/nelsayed/local/bin/bash -q large -l walltime=72:00:00"}
export PBS_LOG=${PBS_LOG-" -j eo -e ibissub00.umiacs.umd.edu:${HOME}/outputs/pbs.out -m n"}
export PBS_ARGS=${PBS_ARGS-"$PBS_THROUGHPUT $PBS_LOG"}
export RAW="${LAB}/raw_data"
export REF="${LAB}/ref_data"
export SCRATCH=${SCRATCH-"/cbcb/nelsayed-scratch/${USER}"}
#export TRINITY_HOME="${PROG}/trinityrnaseq_r2013-02-25"
#export R_LIBS=$PREFIX/R
#export PERLIO=stdio
#export PERL5LIB=$PREFIX/perl/lib/perl5
#
export PERL5LIB=$HOME/perl5/lib/perl5 

# CXX Flags
export MYCFLAGS="-O3 -I$PREFIX/include -L$PREFIX/lib"

# Required to compile Cairo
#export PKG_CONFIG_PATH=$PREFIX/lib/pkgconfig

#export JAR_DIR="$PREFIX/jar"
#CLASSPATH_STMT="export CLASSPATH=$JAR_DIR"
#for jarfile in $(/bin/ls $JAR_DIR/*.jar); do
#    CLASSPATH_STMT="$CLASSPATH_STMT:$jarfile"
#    ALIAS_STMT="alias $(basename $jarfile .jar)=\"java -jar $jarfile\""
#    eval $(echo $ALIAS_STMT)
#done
#eval $(echo $CLASSPATH_STMT)

# Biopieces
#export BP_DIR="/cbcb/lab/nelsayed/local/biopieces"
#export BP_DATA="/cbcb/lab/nelsayed/local/biopieces/data"
#export BP_TMP="/cbcb/lab/nelsayed/local/biopieces/tmp"
#export BP_LOG="/cbcb/lab/nelsayed/local/biopieces/log"

#source "$BP_DIR/bp_conf/bashrc"

# Fastq
fastq_count() {
if [ $1 ]; then
    RESULT=$1
  else
    RESULT=`dialog --stdout --title "Please choose a file" "$@" --fselect $(pwd)/ 20 40`
    retval=$?
  fi
  zcat -f $RESULT | echo $((`wc -l`/4))
}

fastq_filter () {
  if [ $1 ]; then
    RESULT=$1
  else
    RESULT=`dialog --stdout --title "Please choose a file" "$@" --fselect $(pwd)/ 20 40`
  fi
  BASENAME=$(basename ${RESULT} .gz)
  BASENAME=$(basename ${BASENAME} .fastq)
  CMD="zcat -f $RESULT | grep -A 3 '^@.* [^:]*:N:[^:]*:' | grep -v \"^--\"$ > ${BASENAME}_filtered.fastq"
  echo "Running $CMD"
  eval $CMD
}

function end_log() {
    if [ $1 ]; then
    PBS_LOGFILE=$1
    else
    PBS_LOGFILE="/dev/stdout"
    fi
    MYRET=$?
    echo ""
    DATE=$(date)
    HOST=$(hostname)
    echo "Finishing ${PBS_JOBNAME} at ${DATE} on ${HOST}." >> $PBS_LOGFILE
    echo "This job took ${SECONDS} and returned ${MYRET}." >> $PBS_LOGFILE
    echo "" >> $PBS_LOGFILE
}

function fastq_count() {
    if [ $1 ]; then
    RESULT=$1
    else
    RESULT=`dialog --stdout --title "Please choose a file" "$@" --fselect $(pwd)/ 20 40`
    retval=$?
    fi
    COUNT=$(zcat -f $RESULT | wc -l)
    ENTRIES=$(( $COUNT / 4 ))
    echo "$RESULT $ENTRIES"
    return $ENTRIES
}

function fastq_filter() {
    if [ $1 ]; then
    RESULT=$1
    else
    RESULT=`dialog --stdout --title "Please choose a file" "$@" --fselect $(pwd)/ 20 40`
    fi
    BASENAME=$(basename ${RESULT} .gz)
    BASENAME=$(basename ${BASENAME} .fastq)
    CMD="zcat -f $RESULT | grep -A 3 '^@.* [^:]*:N:[^:]*:' | grep -v \"^--\"$ > ${BASENAME}_filtered.fastq"
    echo "Running $CMD"
    eval $CMD
}

function fastq_count_pigz() {
    for file in $@; do
    PIGZ_COUNT=$(unpigz -p `cpus` -c $file | wc -l)
    ENTRIES=$(( $PIGZ_COUNT / 4 ))
    echo "$file $ENTRIES"
    done
}

function freemem {
    MEM=$(/usr/bin/vmstat | /usr/bin/tail -n 1 | /bin/awk '{print $4}')
    echo $MEM
    return $MEM
}

function nodes {
    NUM_NODES=$(pbsnodes -a | grep "^[a-z]" | wc -l)
    FREE_NODES=$(pbsnodes -a | grep "state \= free" | wc -l)
    FREE_CPUS=$(pbsnodes -a | grep -C 1 "state \= free" | grep "np \=" | awk '{print $3}')
    JOBS=$(pbsnodes -a | grep "jobs =" | awk -F "=" '{print $2}')
    AVAILMEM=$(pbsnodes -a | grep availmem | awk -F "availmem" '{print $2}' | sed 's/kb.*$//g' | sed 's/\=//g')
    TOTALMEM=$(pbsnodes -a | grep availmem | awk -F "totmem" '{print $2}' | sed 's/kb.*$//g' | sed 's/\=//g')
    PHYSMEM=$(pbsnodes -a | grep availmem | awk -F "physmem" '{print $2}' | sed 's/kb.*$//g' | sed 's/\=//g')

    FREE_CPUS=$(count $FREE_CPUS)
    JOBS=$(count inc $JOBS)
    AVAILMEM=$(count $AVAILMEM)
    TOTALMEM=$(count $TOTALMEM)
    PHYSMEM=$(count $PHYSMEM)
    PCTMEM=$(( $AVAILMEM * 100 / $TOTALMEM  ))

    TOTALMEM=$(( $TOTALMEM / 1000000 ))
    AVAILMEM=$(( $AVAILMEM / 1000000 ))
    PHYSMEM=$((  $PHYSMEM  / 1000000 ))
    echo "There are $NUM_NODES total nodes, $FREE_NODES are unused, comprising $FREE_CPUS idle processors."

    echo "There are $JOBS running jobs."
    echo "Of $TOTALMEM Gb memory, $PHYSMEM is physical, and $AVAILMEM is available. ${PCTMEM}% free."
}

function qr {
    export WD=${PWD}
    export PBS_ARGS=" -V -S /cbcb/lab/nelsayed/local/bin/Rscript -k eo -j eo -e ${HOME}/outputs/ -m n"
    export INPUTS=$@
    CMD="qsub $PBS_ARGS $1"
    eval $CMD
}

function q {
    export WD=${PWD}
    if [ $3 ]; then
    export WD=$3
    fi
    if [ $2 ]; then
    export IN=$2
    fi
    
    export PBS_ARGS=${PBS_ARGS-" -V -S /bin/bash -q workstation -l walltime=12:00:00 -k eo -j eo -e ${HOME}/outputs/ -m n "}
    echo "The working directory is: ${WD}"
    echo "The input file is: ${IN}, correct?"
    sleep 3
    if [ -e $1 ]; then
    CMD="qsub $PBS_ARGS $1"
    else
    CMD="qsub $PBS_ARGS ${HOME}/bin/$1"
    fi
    echo "Running: $CMD"
    eval $CMD
}

function qattribs {
    QUEUES=("new_large" "new_throughput" "high_throughput")
    for q in $QUEUES; do
    echo "The attributes of the $q queue are:"
    CMD="qmgr -c \"print queue $q\" | grep -v \"^#\" | grep -v \"^create\" | sed 's/^set queue//g'"
    eval $CMD
    echo ""
    done
}

function qdelall {
    JOBS=$(qstat | grep ${USER} | awk '{print $1}' )
    for JB in $JOBS; do
    qdel $JB
    done
}

function qdelrange {
    for i in {$1..$2}; do
        qdel $i.cbcbsrv 
    done
}

function qs {
    CMD="qstat | grep ${USER} "
    if [ $@ ]; then
    CMD="${CMD} $@"
    fi
    eval $CMD
}

function qwho {
    QUSERS=$(qstat -a | grep "^[0-9]" | awk '{print $2}' | sort | uniq)
    for acuser in $QUSERS; do
    USER_JOBS=$(qstat -a -u $acuser | grep "^[0-9]" | wc -l)
    RUNNING_JOBS=$(qstat -u $acuser -r | grep "^[0-9]" | wc -l)
    RMEM=$(qstat -u $acuser | grep "^[0-9]" | awk '{print $8}' | sed 's/[a-z]//g')
    UMEM=$(qstat -u $acuser -r | grep "^[0-9]" | awk '{print $8}' | sed 's/[a-z]//g')
    RCORES=$(qstat -u $acuser | grep "^[0-9]" | awk '{print $7}' | sed 's/[a-z]//g' | grep -v "\-\-")
    UCORES=$(qstat -u $acuser -r | grep "^[0-9]" | awk '{print $7}' | sed 's/[a-z]//g' | grep -v "\-\-")
    REQ_MEM=$(count $RMEM)
    USED_MEM=$(count $UMEM)
    REQ_CORES=$(count $RCORES)
    USED_CORES=$(count $UCORES)
    QUEUED_JOBS=$(( $USER_JOBS - $RUNNING_JOBS ))
    QUEUED_MEM=$(( $REQ_MEM - $USED_MEM ))
    QUEUED_CORES=$(( $REQ_CORES - $USED_CORES ))
    echo "$acuser requested $USER_JOBS jobs, $RUNNING_JOBS are running, $QUEUED_JOBS are waiting."
    echo "$acuser requested $REQ_MEM gb memory, $USED_MEM gb is being used, $QUEUED_MEM is waiting."
    echo "$acuser requested $REQ_CORES cores, $USED_CORES are being used, $QUEUED_CORES are waiting."
    echo ""
    done
}

function start_log() {
#    if [ $1 ]; then
#    PBS_LOGFILE=$1
#    else
    MYWD=${PBS_O_WORKDIR-"$LAB/scripts"}
    STARTLOGFILE="${MYWD}/startlog.out"
#    fi
    DATE=$(date)
    HOST=$(hostname)
    CPUS=$(cpus)
    MEM=$(freemem)
    OUTDIR=$PBS_O_WORKDIR
    OUTDIR=${OUTDIR-"."}
    JOBNAME=$PBS_JOBNAME
    JOBNAME=${JOBNAME-"STDIN"}
    echo "Starting ${PBS_JOBNAME} in queue: ${PBS_QUEUE} at ${DATE} on ${HOST}, which has ${CPUS} cpus and ${MEM} free memory." >> $STARTLOGFILE
    echo "This system is currently being used by:" >> $STARTLOGFILE
    w >> $STARTLOGFILE
    echo "This job is running from ${PBS_O_WORKDIR}." >> $STARTLOGFILE
    echo "" >> $STARTLOGFILE
    DSTAT_CMD="dstat -t -c -d -n -g -m -y -p -r --fs --tcp --vm --proc --output=${PBS_O_WORKDIR}/${PBS_JOBNAME}.csv 2>/dev/null 1>&2 &"
    echo "Running dstat with: $DSTAT_CMD"
    eval $DSTAT_CMD
}

# PBS node names
alias pbsnode-names='pbsnodes | grep --color=never "^[a-z0-9]*.umiacs.umd.edu$"'

# Bedops gff2bed ##FASTA work-around (should be fixed in upcoming version)
# 2014/03/19
function gff2bed() {
    line_num=$(expr $(grep -nr "##FASTA" $1 | awk '{print $1}' FS=":") - 1)
    outfile=$(basename $1 gff)"bed"
    head -n $line_num $1 | $LAB/local/bin/gff2bed - > $outfile
    igvtools index $outfile
}

# Don't do more work than necessary
export ZSHLOCAL_LOADED='TRUE'

#CPATH=/cbcb/lab/nelsayed/local/lib/python2.7/site-packages/numpy/core/include:$CPATH
